#include "ot/user/gen/<%= it.service.name.toLowerCase() %>-server.hpp"
#include "ot/user/gen/method-ids.hpp"
#include "ot/user/user.hpp"
<% if (it.service.methods.some(m => it.hasComplexArgs(m) || m.returns_comm_data)) { %>
#include "ot/lib/mpack/mpack-reader.hpp"
<% } %>

void <%= it.service.name %>ServerBase::process_request(const IpcMessage& msg) {
  // Check for shutdown request (handled by base class)
  if (handle_shutdown_if_requested(msg)) {
    return;  // Server exits in base class
  }

  intptr_t method = IPC_UNPACK_METHOD(msg.method_and_flags);
  uint8_t flags = IPC_UNPACK_FLAGS(msg.method_and_flags);
  IpcResponse resp = {NONE, {0, 0, 0}};

  switch (method) {
<% it.service.methods.forEach(method => { %>
  case MethodIds::<%= it.service.name %>::<%= it.toUpperSnake(method.name) %>: {
<% if (it.hasComplexArgs(method)) { %>
    // Deserialize complex arguments from comm page
    PageAddr comm = ou_get_comm_page();
    MPackReader reader(comm.as_ptr(), OT_PAGE_SIZE);
<% method.args.filter(arg => it.isComplexType(arg)).forEach(arg => { %>
<% if (arg.type === "string") { %>
    StringView <%~ arg.name %>_view;
    reader.read_string(<%~ arg.name %>_view);
    ou::string <%~ arg.name %>(<%~ arg.name %>_view.ptr, <%~ arg.name %>_view.len);
<% } else if (arg.type === "cstring") { %>
    StringView <%~ arg.name %>;
    reader.read_string(<%~ arg.name %>);  // Zero-copy string from comm page
<% } else if (arg.type === "buffer") { %>
    StringView <%~ arg.name %>;
    reader.read_bin(<%~ arg.name %>);  // Zero-copy binary data from comm page
<% } %>
<% }) %>
<% } %>
    auto result = handle_<%= method.name %>(<%
    // Build arg list: complex args from deserialization, simple args from msg.args
    let simpleArgIdx = 0;
    const argList = method.args.map(arg => {
      if (it.isComplexType(arg)) {
        return arg.name;
      } else {
        const argType = arg.type || "int";
        // If it's an int alias, wrap the raw value
        if (it.getType(arg) !== 'uintptr_t' && it.getType(arg) !== 'intptr_t') {
          return `${it.getType(arg)}(msg.args[${simpleArgIdx++}])`;
        }
        return `msg.args[${simpleArgIdx++}]`;
      }
    }).join(', ');
    %><%= argList %>);
    if (result.is_err()) {
      resp.error_code = result.error();
    } else {
<% if (method.returns.length === 0) { %>
      // No return values
<% } else if (method.returns.length === 1) { %>
<% const ret = method.returns[0]; %>
<% if (it.getType(ret) !== 'uintptr_t' && it.getType(ret) !== 'intptr_t' && !it.isComplexType(ret)) { %>
      resp.values[0] = result.value().raw();
<% } else { %>
      resp.values[0] = result.value();
<% } %>
<% } else { %>
      auto val = result.value();
<% method.returns.forEach((ret, i) => { %>
<% if (it.getType(ret) !== 'uintptr_t' && it.getType(ret) !== 'intptr_t' && !it.isComplexType(ret)) { %>
      resp.values[<%= i %>] = val.<%= ret.name %>.raw();
<% } else { %>
      resp.values[<%= i %>] = val.<%= ret.name %>;
<% } %>
<% }) %>
<% } %>
    }
    break;
  }
<% }) %>
  default:
    resp.error_code = IPC__METHOD_NOT_KNOWN;
    break;
  }

  ou_ipc_reply(resp);
}

void <%= it.service.name %>ServerBase::run() {
  while (true) {
    IpcMessage msg = ou_ipc_recv();
    process_request(msg);
  }
}
